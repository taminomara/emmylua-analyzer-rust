# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, CppCXY
# This file is distributed under the same license as the EmmyLua Analyzer
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: EmmyLua Analyzer \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-21 00:14+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/reference/types.md:1
msgid "Types"
msgstr ""

#: ../../source/reference/types.md:3
msgid "Built-in types"
msgstr ""

#: ../../source/reference/types.md:6
#, python-brace-format
msgid ""
"The type {lua}`nil` has one single value, *nil*, whose main property is "
"to be different from any other value; it usually represents the absence "
"of a useful value."
msgstr ""

#: ../../source/reference/types.md:9
#, python-brace-format
msgid ""
"The type {lua}`boolean` has two values, *false* and *true*. Both "
"{lua}`nil` and *false* make a condition false; any other value makes it "
"true."
msgstr ""

#: ../../source/reference/types.md:12
msgid ""
"Lua uses two internal representations for numbers: *integer* and *float*."
" It has explicit rules about when each representation is used, but it "
"also converts between them automatically as needed."
msgstr ""

#: ../../source/reference/types.md:16
#, python-brace-format
msgid ""
"EmmyLua, on the other hand, allows explicitly annotating which "
"representation is expected. The {lua}`number` type can contain both "
"*integer* and *float* values. The {lua}`integer` is a sub-type of "
"{lua}`number`, and only allows *integer* values."
msgstr ""

#: ../../source/reference/types.md:21 ../../source/reference/types.md:24
#: ../../source/reference/types.md:53
msgid "See also"
msgstr ""

#: ../../source/reference/types.md:22 ../../source/reference/types.md:25
#: ../../source/reference/types.md:54
msgid "Lua's [manual on value types]."
msgstr ""

#: ../../source/reference/types.md:15
#, python-brace-format
msgid ""
"The type {lua}`integer` is a sub-type of {lua}`number` that only allows "
"numbers with *integer* representation."
msgstr ""

#: ../../source/reference/types.md:18
#, python-brace-format
msgid ""
"The type {lua}`userdata` is provided to allow arbitrary C data to be "
"stored in Lua variables. A userdata value represents a block of raw "
"memory. There are two kinds of userdata: {lua}`userdata`, which is an "
"object with a block of memory managed by Lua, and {lua}`lightuserdata`, "
"which is simply a C pointer value."
msgstr ""

#: ../../source/reference/types.md:21
#, python-brace-format
msgid ""
"The type {lua}`lightuserdata` is a sub-type of {lua}`userdata` that only "
"allows values with *light userdata* representation."
msgstr ""

#: ../../source/reference/types.md:24
#, python-brace-format
msgid ""
"The type {lua}`thread` represents independent threads of execution and it"
" is used to implement coroutines. Lua threads are not related to "
"operating-system threads. Lua supports coroutines on all systems, even "
"those that do not support threads natively."
msgstr ""

#: ../../source/reference/types.md:27
#, python-brace-format
msgid ""
"The type *table* implements associative arrays, that is, arrays that can "
"have as indices not only numbers, but any Lua value except {lua}`nil` and"
" {lua}`NaN <number>`. (*Not a Number* is a special floating-point value "
"used by the IEEE 754 standard to represent undefined or unrepresentable "
"numerical results, such as `0/0`.)"
msgstr ""

#: ../../source/reference/types.md:33
msgid ""
"While lua allows mixing types of keys and values in a table, EmmyLua has "
"an option to specify their exact types. Simply using type `table` creates"
" a heterogeneous table (equivalent to `table<unknown, unknown>`), while "
"explicitly providing key and value types creates a homogeneous table:"
msgstr ""

#: ../../source/reference/types.md:46
msgid ""
"You can also specify the exact shape of a table by using a *table "
"literal*:"
msgstr ""

#: ../../source/reference/types.md:30
#, python-brace-format
msgid ""
"The type {lua}`any` is compatible with any other type. That is, all types"
" can be converted to and from {lua}`any`."
msgstr ""

#: ../../source/reference/types.md:33
msgid ""
"This type is a way to bypass type checking system and explicitly tell "
"EmmyLua that you know what you're doing."
msgstr ""

#: ../../source/reference/types.md:36
msgid "Tip"
msgstr ""

#: ../../source/reference/types.md:37
#, python-brace-format
msgid ""
"Prefer using {lua}`unknown` instead of {lua}`any` to signal the need  to "
"be careful and explicitly check value's contents."
msgstr ""

#: ../../source/reference/types.md:33
#, python-brace-format
msgid ""
"The type {lua}`unknown` is similar to {lua}`any`, but signifies a "
"different intent."
msgstr ""

#: ../../source/reference/types.md:36
#, python-brace-format
msgid ""
"While {lua}`any` is a way to say \"I know what I'm doing\", "
"{lua}`unknown` is a way to say \"better check this value before using "
"it\"."
msgstr ""

#: ../../source/reference/types.md:36
#, python-brace-format
msgid ""
"Void is an alias for {lua}`nil` used in some code bases. Prefer using "
"{lua}`nil` instead."
msgstr ""

#: ../../source/reference/types.md:39
#, python-brace-format
msgid ""
"A special type used with class methods. It can be thought of as a generic"
" parameter that matches type of the function's implicit argument `self`. "
"That is, when a function is called via colon notation (i.e. "
"`table:method()`), {lua}`self` is replaced with the type of expression "
"before the colon."
msgstr ""

#: ../../source/reference/types.md:45
msgid ""
"This is especially handy when dealing with inheritance. Consider the "
"following example:"
msgstr ""

#: ../../source/reference/types.md:63
#, python-brace-format
msgid ""
"Here, EmmyLua infers type of `child` to be `Child`, even though `new` was"
" defined in its base class. This is because `new` uses {lua}`self` as its"
" return type."
msgstr ""

#: ../../source/reference/types.md:41
msgid "Metaprogramming library"
msgstr ""

#: ../../source/reference/types.md:44
#, python-brace-format
msgid ""
"A type for {lua}`assert` function. Given a nullable type `T` expands to a"
" non-nullable version of `T`."
msgstr ""

#: ../../source/reference/types.md:47
msgid "For example, if `T` is `string?`, then `std.NotNull<T>` will be `string`."
msgstr ""

#: ../../source/reference/types.md:57
#, python-brace-format
msgid ""
"A type for {lua}`table.unpack` function. Given a type `T` and optional "
"literal types `Start` and `End`, expands to the type of expression "
"`table.unpack(t, start, end)`."
msgstr ""

#: ../../source/reference/types.md:61 ../../source/reference/types.md:64
msgid "Example:"
msgstr ""

#: ../../source/reference/types.md:72
msgid "Here, `a`, `b` and `c` will be inferred as integers."
msgstr ""

#: ../../source/reference/types.md:60
#, python-brace-format
msgid ""
"A type for {lua}`rawget` function. Given a type `T` and a literal type "
"`K`, expands to the type of expression `rawget(t, k)`."
msgstr ""

#: ../../source/reference/types.md:74
msgid "Here, `std.RawGet<Example, \"value\">` will be expanded to `integer`."
msgstr ""

#: ../../source/reference/types.md:63
msgid "A wrapper for matching literal types in generics."
msgstr ""

#: ../../source/reference/types.md:65
msgid ""
"By default, generics variables that match literal values decay to values'"
" base types:"
msgstr ""

#: ../../source/reference/types.md:81
msgid ""
"Here, type of `value` will be inferred as `string` even though "
"`original`'s type was `\"literal\"`."
msgstr ""

#: ../../source/reference/types.md:84
msgid ""
"We can prevent this behavior by wrapping generic pattern for `T` into "
"`std.ConstTpl<T>`:"
msgstr ""

#: ../../source/reference/types.md:100
msgid "Here, type of `value` will be inferred as `\"literal\"`."
msgstr ""

